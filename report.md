# Routes

## Задание
Ваш друг не так успешен как вы и работает курьером. Он попросил вас помочь ему с его работой. Каждый день он получает заказы в разных частях города. Ему нужно получить оптимальный маршрут передвижения по клиентам. Более того, начальство требует от него указать приблизительное время доставки для каждого заказчика.

## Теоретическая часть
Задание очевидным образом сводится к решению задачи коммивояжера.

Задача о коммивояжере (англ. Travelling salesman problem, TSP) — задача, в которой коммивояжер должен посетить N городов, побывав в каждом из них ровно по одному разу и завершив путешествие в том городе, с которого он начал. В какой последовательности ему нужно обходить города, чтобы общая длина его пути была наименьшей?

Данная задача является NP-трудной, а это значит, что, с учетом распространенной, но недоказанной гипотезы о неравенстве классов P и NP, нельзя найти ее решение за полиномиальное от количества городов времени. Более того, задача коммивояжёра относится к числу трансвычислительных: уже при относительно небольшом числе городов (66 и более) она не может быть решена методом перебора вариантов никакими теоретически мыслимыми компьютерами за время, меньшее нескольких миллиардов лет.

### Формулировка задачи
В терминах теории графов задачу можно сформулировать так: имеется полный ориентированный граф G = (V, E), каждой дуге (u, v) которого сопоставлен вес c(u, v). Предполагается, что c(u, v) ≥ 0; c(u, u) = ∞ для всех u, v ∈ V. Требуется найти в этом графе гамильтонов контур наименьшей стоимости. Также, задача может быть сформулирована с учетом c(u, v) = c(v, u) для всех u, v ∈ V, т. е. граф можно считать неориентированным. Такая задача называется симметричной задачей коммивояжера.

### Методы решения
Все эффективные (сокращающие полный перебор) методы решения задачи коммивояжёра — методы эвристические. В большинстве эвристических методов находится не самый эффективный маршрут, а приближённое решение. Зачастую востребованы так называемые any-time-алгоритмы, то есть, постепенно улучшающие некоторое текущее приближенное решение. На практике применяются различные модификации более эффективных методов: метод ветвей и границ и метод генетических алгоритмов, а также алгоритм муравьиной колонии.

В данном случае будем решать симметричную задачу коммивояжера. Для малых (меньше 8 вершин) графов будем находить точное решение методом полного перебора. Для остальных - находить приближенное решение, используя для этого частный случай метода ветвей и границ - алгоритм Литтла.

Почему именно его? Например, алгоритм ближайшего соседа прост в реализации, быстро выполняется, но, как и другие «жадные» алгоритмы, может выдавать неоптимальные решения. Алгоритм имитации отжига рекомендуется использовать только при малом количестве вершин (до 10), где он показывает приемлемые результаты. Муравьиные и генетические алгоритмы, хоть и могут работать быстрее, дают менее оптимальное решение, а также могут возникнуть некоторые сложности при их реализации. Алгоритм Литтла при увеличении количества вершин дает решение, близкое к оптимальному, хотя и требует больше ресурсов, чем другие алгоритмы.

#### Метод ветвей и границ
Метод ветвей и границ (англ. branch and bound) — общий алгоритмический метод для нахождения оптимальных решений различных задач оптимизации, особенно дискретной и комбинаторной оптимизации. По существу, метод является вариацией полного перебора с отсевом подмножеств допустимых решений, заведомо не содержащих оптимальных решений.

Общая идея метода может быть описана на примере поиска минимума функции f(x) на множестве допустимых значений переменной x, причем функция и переменная могут быть произвольной природы.

Для метода ветвей и границ необходимы две процедуры: ветвление и нахождение оценок (границ).

Процедура ветвления состоит в разбиении множества допустимых значений переменной на подобласти (подмножества) меньших размеров. Процедуру можно рекурсивно применять к подобластям. Полученные подобласти образуют дерево, называемое деревом поиска или деревом ветвей и границ. Узлами этого дерева являются построенные подобласти (подмножества множества значений переменной).

Процедура нахождения оценок заключается в поиске верхних и нижних границ для решения задачи на подобласти допустимых значений переменной.

В основе метода ветвей и границ лежит следующая идея: если нижняя граница значений функции на подобласти A дерева поиска больше, чем верхняя граница на какой-либо ранее просмотренной подобласти B, то A может быть исключена из дальнейшего рассмотрения (правило отсева). Обычно минимальную из полученных верхних оценок записывают в глобальную переменную, тогда любой узел дерева поиска, нижняя граница которого больше значения этой переменной, может быть исключён из дальнейшего рассмотрения. Если нижняя граница для узла дерева совпадает с верхней границей, то это значение является минимумом функции и достигается на соответствующей подобласти.

#### Алгоритм Литтла

1. В каждой строке матрицы стоимости найдем минимальный элемент и вычтем его из всех элементов строки. Сделаем это и для столбцов, не содержащих нуля. Получим матрицу стоимости, каждая строка и каждый столбец которой содержат хотя бы один нулевой элемент.

2. Для каждого нулевого элемента матрицы, рассчитываем коэффициент k, который равен сумме минимальных элементов столбца и строки этого нуля. Выбираем нуль с максимальным коэффициентом (если таковых несколько выбираем любой из них). Вносим в гамильтонов контур соответствующую дугу.

3. Удаляем строку и столбец, на пересечении которого выбранный нами нуль.

4. Проверяем граф на наличие точек возврата, если есть таковые, то меняем их значение на максимальное. Повторяем предыдущие действия пока не останется матрица порядка 2.

5. Вносим в гамильтонов контур недостающие дуги. Получаем искомый контур.

В ходе решения ведется постоянный подсчет текущего значения нижней границы. Нижняя граница равна сумме всех вычтенных элементов в строках и столбцах. Итоговое значение нижней границы должно совпасть с длиной результирующего контура.

Естественно, в случае симметричной задачи коммивояжера, считаем дуги ребрами и находим гамильтонов цикл.

## Формат входных и выходных данных
### Входные данные
Представляются в JSON-формате. Сначала идет начальная вершина и начальный момент времени, затем множество вершин, которые необходимо посетить, далее массив всех вершин графа (состоит из вершин, которые необходимо посетить, и начальной вершины) и матрица весов для такого же порядка вершин, как и в массиве (весом является, соответственно, время в пути).
>{
    "initial": "c",
    "time": "10:00",
    "clients": ["a","b"],
    "vertices": ["a", "b", "c"],
    "graph": [
        [inf, 10, 5],
        [10, inf, 12],
        [5, 12, inf]
    ]
}

### Выходные данные
Также в JSON-формате в виде массива, представляющего собой последовательность посещения вершин с указанным для каждой временем доставки (с учетом начальной вершины, которой начинается и заканчивается маршрут).
>{
    "bypass": [
        {
            "c": "10:00"
        },
        {
            "a": "10:05"
        },
        {
            "b": "10:15"
        },
        {
            "c": "10:27"
        }
    ]
}

## План решения задачи
Для решения задачи выбран язык python.
#### 1. Реализовать процесс инициализации начальных данных (в том числе с проверкой валидности входных данных).
В памяти представлять граф будем посредством матрицы весов. Конечно, у меня не могла не возникнуть идея хранить его как хэш-таблицу с ключами в виде можеств из двух вершин и значениями в виде длин, в том числе и принимать на вход подобные данные, однако выигрыш по памяти не столь значителен в данном случае (все таки, с учетом условий задачи, вряд ли курьеру необходимо будет посетить очень много вершин. Кроме того, курьер по идеи знает, сколько от каждой точки до каждой, а, так как расчет ведется для графа с вершинами из клиентов и начальной, то он (граф) вообще будет полным. ). Я не утверждаю, что матрица весов будет эффективнее, однако она кроме того пригодится при работе алгоритма. Так зачем нам сначала сохранять граф в одну структуру данных, пусть и более оптимальную, чтобы потом построить по ней матрицу?
#### 2. Реализовать сам метод решения.
#### 3. Пофиксить баги.
К слову, данный пункт плана актуален на протяжении всего выполнения работы.
