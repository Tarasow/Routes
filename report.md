# Routes

## Задание
Ваш друг не так успешен как вы и работает курьером. Он попросил вас помочь ему с его работой. Каждый день он получает заказы в разных частях города. Ему нужно получить оптимальный маршрут передвижения по клиентам. Более того, начальство требует от него указать приблизительное время доставки для каждого заказчика.

## Теоретическая часть
Задание очевидным образом сводится к решению задачи коммивояжера.

Задача о коммивояжере (англ. Travelling salesman problem, TSP) — задача, в которой коммивояжер должен посетить N городов, побывав в каждом из них ровно по одному разу и завершив путешествие в том городе, с которого он начал. В какой последовательности ему нужно обходить города, чтобы общая длина его пути была наименьшей?

Данная задача является NP-трудной, а это значит, что, с учетом распространенной, но недоказанной гипотезы о неравенстве классов P и NP, нельзя найти ее решение за полиномиальное от количества городов времени. Более того, задача коммивояжёра относится к числу трансвычислительных: уже при относительно небольшом числе городов (66 и более) она не может быть решена методом перебора вариантов никакими теоретически мыслимыми компьютерами за время, меньшее нескольких миллиардов лет.

### Формулировка задачи
В терминах теории графов задачу можно сформулировать так: имеется полный ориентированный граф G = (V, E), каждой дуге (u, v) которого сопоставлен вес c(u, v). Предполагается, что c(u, v) ≥ 0; c(u, u) = ∞ для всех u, v ∈ V. Требуется найти в этом графе гамильтонов контур наименьшей стоимости. Также, задача может быть сформулирована с учетом c(u, v) = c(v, u) для всех u, v ∈ V, т. е. граф можно считать неориентированным. Такая задача называется симметричной задачей коммивояжера.

### Методы решения
Все эффективные (сокращающие полный перебор) методы решения задачи коммивояжёра — методы эвристические. В большинстве эвристических методов находится не самый эффективный маршрут, а приближённое решение. Зачастую востребованы так называемые any-time-алгоритмы, то есть, постепенно улучшающие некоторое текущее приближенное решение. На практике применяются различные модификации более эффективных методов: метод ветвей и границ и метод генетических алгоритмов, а также алгоритм муравьиной колонии.

В данном случае будем решать симметричную задачу коммивояжера. Для малых (меньше 8 вершин) графов будем находить точное решение методом полного перебора. Для остальных - находить приближенное решение, используя для этого частный случай метода ветвей и границ - алгоритм Литтла.

Почему именно его? Например, алгоритм ближайшего соседа прост в реализации, быстро выполняется, но, как и другие «жадные» алгоритмы, может выдавать неоптимальные решения. Алгоритм имитации отжига рекомендуется использовать только при малом количестве вершин (до 10), где он показывает приемлемые результаты. Муравьиные и генетические алгоритмы, хоть и могут работать быстрее, дают менее оптимальное решение, а также могут возникнуть некоторые сложности при их реализации. Алгоритм Литтла при увеличении количества вершин дает решение, близкое к оптимальному, хотя и требует больше ресурсов, чем другие алгоритмы.

#### Метод ветвей и границ
Метод ветвей и границ (англ. branch and bound) — общий алгоритмический метод для нахождения оптимальных решений различных задач оптимизации, особенно дискретной и комбинаторной оптимизации. По существу, метод является вариацией полного перебора с отсевом подмножеств допустимых решений, заведомо не содержащих оптимальных решений.

Общая идея метода может быть описана на примере поиска минимума функции f(x) на множестве допустимых значений переменной x, причем функция и переменная могут быть произвольной природы.

Для метода ветвей и границ необходимы две процедуры: ветвление и нахождение оценок (границ).

Процедура ветвления состоит в разбиении множества допустимых значений переменной на подобласти (подмножества) меньших размеров. Процедуру можно рекурсивно применять к подобластям. Полученные подобласти образуют дерево, называемое деревом поиска или деревом ветвей и границ. Узлами этого дерева являются построенные подобласти (подмножества множества значений переменной).

Процедура нахождения оценок заключается в поиске верхних и нижних границ для решения задачи на подобласти допустимых значений переменной.

В основе метода ветвей и границ лежит следующая идея: если нижняя граница значений функции на подобласти A дерева поиска больше, чем верхняя граница на какой-либо ранее просмотренной подобласти B, то A может быть исключена из дальнейшего рассмотрения (правило отсева). Обычно минимальную из полученных верхних оценок записывают в глобальную переменную, тогда любой узел дерева поиска, нижняя граница которого больше значения этой переменной, может быть исключён из дальнейшего рассмотрения. Если нижняя граница для узла дерева совпадает с верхней границей, то это значение является минимумом функции и достигается на соответствующей подобласти.

#### Алгоритм Литтла

1. В каждой строке матрицы стоимости найдем минимальный элемент и вычтем его из всех элементов строки. Сделаем это и для столбцов, не содержащих нуля. Получим матрицу стоимости, каждая строка и каждый столбец которой содержат хотя бы один нулевой элемент.

2. Для каждого нулевого элемента матрицы, рассчитываем коэффициент k, который равен сумме минимальных элементов столбца и строки этого нуля. Выбираем нуль с максимальным коэффициентом (если таковых несколько выбираем любой из них). Вносим в гамильтонов контур соответствующую дугу.

3. Удаляем строку и столбец, на пересечении которого выбранный нами нуль.

4. Проверяем граф на наличие точек возврата, если есть таковые, то меняем их значение на максимальное. Повторяем предыдущие действия пока не останется матрица порядка 2.

5. Вносим в гамильтонов контур недостающие дуги. Получаем искомый контур.

В ходе решения ведется постоянный подсчет текущего значения нижней границы. Нижняя граница равна сумме всех вычтенных элементов в строках и столбцах. Итоговое значение нижней границы должно совпасть с длиной результирующего контура.

Естественно, в случае симметричной задачи коммивояжера, считаем дуги ребрами и находим гамильтонов цикл.

## Инструкция по использованию программы
Для запуска программы требуется Python версии не ниже 3.5. Для запуска в папке с программой выполнить
>python <имя_файла_с_входными_данными> <имя_файла_для_выходных_данных>

Для запуска тестов в папке test выполнить
>PYTHONPATH=../ python -m unittest *.py [-v="подробный вывод"]

Либо же запустить скрипт (работает в linux или терминале mingw под Windows)
>./run_tests.sh

## Описание логики программы
Итак, программа работает следующим образом:

* При запуске сначала проверяется наличие файла с входными данными и их корректность. Если все в порядке, прочитанные данные передаются далее в функцию получения решения.
* Данная функция, исходя из размера входных данных, передает их либо в алгоритм полного перебора (для количества вершин, меньше или равного 8), либо в алгоритм Литтла.
* В алгоритме полного перебора все и так понятно - находим все перестановки множества вершин без начальной, а затем находим длины всех маршрутов. Если очередной найденный маршрут короче предыдущего найденного, запоминаем его как новый наиболее короткий.
* В алгоритме Литтла, соответственно, происходит описанное в теоретической части. Для найденного маршрута запоминается его длина как нижняя граница. Если при дальнейшем поиске, еще не получив очередной ответ, текущая граница уже равна нижней, то далее эта ветвь не рассматривается. Таким образом, улучшается время работы программы и уменьшается используемая память.
* В конце работы каждого из алгоритмов получаем выходные данные по найденному оптимальному маршруту. Данное решение записывается в выходной файл.

## Формат входных и выходных данных
### Входные данные
Представляются в JSON-формате. Сначала идет начальная вершина и начальный момент времени, затем множество вершин, которые необходимо посетить, далее массив всех вершин графа (состоит из вершин, которые необходимо посетить, и начальной вершины) и матрица весов для такого же порядка вершин, как и в массиве (весом является, соответственно, время в пути, выраженное в минутах. Выражение времени в минутах сделано для более быстрой работы, ибо таким образом при подсчете и сравнении времени в пути используются лишь целые числа. Естественно, в выходных данных все конвертируется в красивый формат времени с днями, часами и минутами).
>{
    "initial": "c",
    "time": "10:00",
    "clients": ["a","b"],
    "vertices": ["a", "b", "c"],
    "graph": [
        ["inf", 10, 5],
        [10, "inf", 12],
        [5, 12, "inf"]
    ]
}

### Выходные данные
Также в JSON-формате в виде массива, представляющего собой последовательность посещения вершин с указанным для каждой временем доставки (с учетом начальной вершины, которой начинается и заканчивается маршрут).
>{
    "bypass": [
        {
            "c": "10:00"
        },
        {
            "a": "10:05"
        },
        {
            "b": "10:15"
        },
        {
            "c": "10:27"
        }
    ]
}

Если время начинает превышать текущие сутки, первые до знака тире цифры будут обозначать дни. Например, "1-00:35" - следующий день, 00 часов 35 минут соответственно.

## Тесты
К программе приложены тесты. Про то, как их запускать, см. "инструкцию по использованию программы". Также, при очередном коммите файлов программы на github, Travis прогоняет тесты и в README.md стоит картинка со статусом последнего запуска тестов.

### Описание тестов
#### Файл test_brute_force.py
Функции для тестирования алгоритма полного перебора. Проверяют получение правильного ответа, сам полный перебор и получение длины найденного маршрута.

#### Файл test_data_validation.py
Функции для тестирования алгоритмов проверки исходных данных. Проверяют, соответственно, корректность их работы на неправильных входных данных

#### Файл test_data_init.py
Функции для проверки ошибок в случае отсутствия входного файла или неверного формата данных (json).

#### Файл test_littles_algorithm.py
Функции для тестирования алгоритма Литтла. Проверяют различные его части, например, подготовку матрицы, поиск нулей и коэффициентов, получение ответа и тд.

#### Файл test_route_time_helper.py
Проверка вспомогательной функции calc_time, которая используется для правильного подсчета времени при получении ответа.

#### Файл test_solver.py
Функции для тестирования работы самой программы. Основаны на сравнении файлов образца ответа и полученного программой ответа.

## Оценка сложности основных алгоритмов
#### Для метода грубой силы имеем:
Сложность полного перебора **O((n-1)!)** - так как мы ищем длину пути для каждого из возможных, а их как раз **(n-1)!** (число перестановок n-1 элементов). При этом сложность нахождения пути для перестановки **O(n)** (нам необходимо пройтись по массиву вершин, складывая расстояния между ними). Таким образом, сложность метода грубой силы **O(n!)**.

#### Для алгоритма Литтла имеем:
Так как алгоритм представляет собой частный случай метода ветвей и границ, поэтому сложность в худшем случае также O(n!).

Рассмотрим сложности частей алгоритма. Так, подготовка матрицы - **O(n^3)**, так как за O(n) мы находим минимальный элемент в строке, за O(n) вычитаем его из всех элементов строки, а также O(n) требуется для выполнения этого для всех строк. Аналогично для столбцов, поэтому O(n^3 + n^3) = O(n^3)

Поиск нулей в матрице - **O(n^2)**. Также **O(n^2)** для подсчета коэффициента для одного из нулей. Сокращение матрицы и добавление вершин в текущий ответ - **O(n)**


## Оценка использования памяти основными алгоритмами
#### Для метода грубой силы имеем:
Для хранения всех возможных вариантов нам потребуется **O((n-1)!)** памяти. При этом используемые для получения всех этих вариантов перестановки нам хранить не трубется, так как в данном случае используется генератор, размер которого чуть менее, чем в два раза больше размера массива из n-1 элеметов. Поэтому для хранения генератора нужно **O(2n) = O(n)** памяти, а также константная память **O(1)** для хранения текущей минимальной длины и **O(n)** - для текущего лучшего маршрута. Таким образом, метод грубой силы расходует **O((n-1)!)** памяти.

#### Для алгоритма Литтла имеем:
Так как алгоритм сначала находит одно решение, а при дальнейшем поиске идет сравнение текущей границы с полученной нижней границей, то в худшим случаем будет такой, когда перед подсчетом решения на каждой из итераций идет ветвление, из-за которого происходит копирование текущей матрицы. Таким образом, с учетом занимания матрицей размера NxN памяти O(n^2), занимаемая в этом случае память **O(n^2) + (n-1)^2 + ... + 2^2)** (так как для матрицы размера 2x2 копирования не будет). Поскольку сумма квадратов от 0 до n равна 1/6*n(n+1)(2n+1), это даст сложность **O(n^3)**.

Для хранения текущего ответа требуется **O(n)** памяти, а значит алгоритм использует **O(n^3)** памяти.
